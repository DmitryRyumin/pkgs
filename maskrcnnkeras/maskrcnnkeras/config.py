#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Конфигурационный файл Mask R-CNN
"""

# ######################################################################################################################
# Импорт необходимых инструментов
# ######################################################################################################################
import numpy as np  # Научные вычисления


# ######################################################################################################################
# Настройки для Mask R-CNN
# ######################################################################################################################
class Config(object):
    """Класс для настройки Mask R-CNN"""

    # Название конфигурации (Например: 'COCO', 'Experiment 1')
    NAME = None  # Необходимо переопределить

    # Количество GPU для использования. При использовании CPU значение должно быть установлено 1
    GPU_COUNT = 1

    # Количество изображений для тренировки на каждом GPU
    #
    # Данное значение нужно отрегулировать в зависимости от памяти GPU и размеров изображения
    # Например: 12 ГБ GPU может обрабатывать 2 изображения размером 1024x1024px
    IMAGES_PER_GPU = 2

    # Количество тренировочных шагов за эпоху
    #
    # Данное значение не должно соответствовать размеру обучающего набора
    # Обновления Tensorboard происходит в конце каждой эпохи, поэтому чем меньше данное значение тем чаще обновляется
    # Tensorboard. Статистика валидации также рассчитывается в конце каждой эпохи, и она может занять некоторое время,
    # поэтому рекомендуется не устанавливать данное значение слишком маленьким, чтобы не тратить много времени на
    # статистику валидации
    STEPS_PER_EPOCH = 1000

    # Количество этапов проверки, выполняемых в конце каждой эпохи
    # Большее число повышает точность статистики, но замедляет обучение
    VALIDATION_STEPS = 50

    # Архитектура магистральной сети
    #
    # Поддерживаемые значения: 'resnet50', 'resnet101' или объект model.resnet_graph
    BACKBONE = 'resnet101'

    # Работает только в том случае если BACKBONE = model.resnet_graph
    #
    # Смотреть model.compute_backbone_shapes
    COMPUTE_BACKBONE_SHAPE = None

    # Шаг каждого слоя пирамидальной сети
    #
    # Данные значения основаны на архитектуре магистральной сети resnet101
    BACKBONE_STRIDES = [4, 8, 16, 32, 64]

    # Размер полносвязных слоев в графе классификации
    FPN_CLASSIF_FC_LAYERS_SIZE = 1024

    # Size of the top-down layers used to build the feature pyramid
    TOP_DOWN_PYRAMID_SIZE = 256

    # Размер слоев, используемых для классификации объектов (количество классов)
    NUM_CLASSES = 1  # Необходимо переопределить

    # Длина квадратного якоря (значения указываются в пикселях)
    RPN_ANCHOR_SCALES = (32, 64, 128, 256, 512)

    # Соотношение якорей в каждой ячейке (ширина/высота)
    #
    # Значение 1 представляет квадратный якорь, а 0,5 - широкий якорь
    RPN_ANCHOR_RATIOS = [0.5, 1, 2]

    # Шаг якорей
    #
    # 1, то якоря создаются для каждой ячейки в карте объектов
    # 2, то якоря создаются для каждой второй ячейки в карте объектов и так далее
    RPN_ANCHOR_STRIDE = 1

    # Порог для подавления предложений от региональной сети
    #
    # Данное значение можно изменять в процессе обучения для увеличения или уменьшения предложений
    RPN_NMS_THRESHOLD = 0.7

    # Количество якорей для обучения региональной сети
    RPN_TRAIN_ANCHORS_PER_IMAGE = 256
    
    # Области сохраняются после tf.nn.top_k и до не максимального подавления
    PRE_NMS_LIMIT = 6000

    # ОБласти сохраняются после не максимального подавления (обучение и вывод)
    POST_NMS_ROIS_TRAINING = 2000
    POST_NMS_ROIS_INFERENCE = 1000

    # Если True, то изменяется размер маски экземпляра до меньшего размера, чтобы уменьшить нагрузку на память
    #
    # Рекомендуется при использовании изображений с высоким разрешением
    USE_MINI_MASK = True
    MINI_MASK_SHAPE = (56, 56)  # (высота, ширина) для маски

    # Изменение размера входного изображения
    #
    # Рекомендуется использовать 'square' режим изменения размера для обучения и прогнозирования
    # В этом режиме изображения масштабируются таким образом, чтобы малая сторона была = IMAGE_MIN_DIM,
    # но при этом гарантировалось, что при масштабировании не будет длинной стороны > IMAGE_MAX_DIM
    # Затем изображение дополняется нулями, чтобы сделать его квадратным, чтобы можно было поместить несколько
    # изображений в один пакет
    #
    # Доступные режимы изменения размера:
    # none:   без изменения размера или заполнения
    # square: изменить размер и дополнить нулями, чтобы получить квадратное изображение размером [max_dim, max_dim]
    # pad64:  ширина и высота с нулями, чтобы сделать их кратными 64
    # crop:   выбор случайных частей изображения
    IMAGE_RESIZE_MODE = 'square'
    IMAGE_MIN_DIM = 800
    IMAGE_MAX_DIM = 1024
    # Минимальный коэффициент масштабирования
    #
    # Например, если установлено значение 2, изображения масштабируются до удвоенной ширины и высоты или более
    IMAGE_MIN_SCALE = 0
    # Количество цветовых каналов на изображение
    #
    # RGB = 3, оттенки серого = 1, RGB-Depth = 4
    IMAGE_CHANNEL_COUNT = 3

    # Среднее изображение (RGB)
    MEAN_PIXEL = np.array([123.7, 116.8, 103.9])

    # Количество областей интереса на изображение
    TRAIN_ROIS_PER_IMAGE = 200

    # Процент положительных областей, использованных для обучения
    ROI_POSITIVE_RATIO = 0.33

    # Пул областей
    POOL_SIZE = 7
    MASK_POOL_SIZE = 14

    # Форма выходной маски
    MASK_SHAPE = [28, 28]

    # Максимальное количество экземпляров для одного изображения
    MAX_GT_INSTANCES = 100

    # Стандартное отклонение уточнения ограничивающей рамки для региональной сети и окончательных обнаружений
    RPN_BBOX_STD_DEV = np.array([0.1, 0.1, 0.2, 0.2])
    BBOX_STD_DEV = np.array([0.1, 0.1, 0.2, 0.2])

    # Максимальное количество итоговых обнаружений
    DETECTION_MAX_INSTANCES = 100

    # Минимальное значение вероятности для принятия обнаруженного экземпляра
    #
    # Области ниже этого порога пропускаются
    DETECTION_MIN_CONFIDENCE = 0.7

    # Не максимальный порог подавления для обнаружения
    DETECTION_NMS_THRESHOLD = 0.3

    # Скорость обучения и импульс
    LEARNING_RATE = 0.001
    LEARNING_MOMENTUM = 0.9

    # Регуляризация снижения веса
    WEIGHT_DECAY = 0.0001

    # Функция потерь для более точной оптимизации
    #
    # Возможно использовать для настройки обучения R-CNN
    LOSS_WEIGHTS = {
        'rpn_class_loss': 1.,
        'rpn_bbox_loss': 1.,
        'mrcnn_class_loss': 1.,
        'mrcnn_bbox_loss': 1.,
        'mrcnn_mask_loss': 1.
    }

    # Использовать региональную сеть обнаружения областей
    USE_RPN_ROIS = True

    # Обучать или заморозить пакетные слои нормализации
    #     None: тренировка сети
    #     False: заморозка сети
    #     True: (не использовать). Установка в режим обучения даже при прогнозировании
    TRAIN_BN = False

    # Градиентная норма отсечения
    GRADIENT_CLIP_NORM = 5.0

    # ------------------------------------------------------------------------------------------------------------------
    # Конструктор
    # ------------------------------------------------------------------------------------------------------------------

    def __init__(self):
        # Эффективный размер партии
        self.BATCH_SIZE = self.IMAGES_PER_GPU * self.GPU_COUNT

        # Размер входного изображения
        if self.IMAGE_RESIZE_MODE == 'crop':
            self.IMAGE_SHAPE = np.array([self.IMAGE_MIN_DIM, self.IMAGE_MIN_DIM, self.IMAGE_CHANNEL_COUNT])
        else:
            self.IMAGE_SHAPE = np.array([self.IMAGE_MAX_DIM, self.IMAGE_MAX_DIM, self.IMAGE_CHANNEL_COUNT])

        # Длина метаданных изображения
        self.IMAGE_META_SIZE = 1 + 3 + 3 + 4 + 1 + self.NUM_CLASSES

    # ------------------------------------------------------------------------------------------------------------------
    #  Внешние методы
    # ------------------------------------------------------------------------------------------------------------------

    # Вывод настроек для Mask R-CNN
    def display(self):
        """
        Вывод настроек для Mask R-CNN
        """

        print('\nКонфигурация:')

        for a in dir(self):
            if not a.startswith('__') and not callable(getattr(self, a)):
                print('{:30} {}'.format(a, getattr(self, a)))

        print('\n')
